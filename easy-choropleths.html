<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="css/leaflet.css" />

<style>

#map {
  width: 800px;
  height: 500px;
}

.info {
  padding: 6px 8px;
  font: 14px/16px Arial, Helvetica, sans-serif;
  background: white;
  background: rgba(255,255,255,0.8);
  box-shadow: 0 0 15px rgba(0,0,0,0.2);
  border-radius: 5px;
}
.info h4 {
  margin: 0 0 5px;
  color: #777;
}

.legend {
  text-align: left;
  line-height: 18px;
  color: #555;
}
.legend i {
  width: 18px;
  height: 18px;
  float: left;
  margin-right: 8px;
  opacity: 0.7;
}

.leaflet-container {
    background: white;
}

</style>


<body>

<div id="map"></div>

<!-- D3 -->
<script src="js/d3.v3.min.js"></script>

<!-- Leaflet -->
<script src="js/leaflet.js"></script>

<!-- Tabletop for Google Docs data pull -->
<script src="js/tabletop.js"></script>

<!-- Underscore for awesome collection comprehensions -->
<script src="js/underscore-min.js"></script>

<!-- ParseURI.js because it's dead-simple and small -->
<!-- See http://blog.stevenlevithan.com/archives/parseuri for details -->
<script src="js/parseuri.js"></script>

<!-- JQuery -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>

<!-- Colorbrewer (from D3) -->
<script src="js/colorbrewer.js"></script>

<script>


//////////////////////////////// Begin DG ////////////////////////////////



window.onload = function() {
  key = parseUri(location).queryKey.key
  if(key) {    
    uri_parameters = parseUri(location).queryKey;
    configureMapOptions(uri_parameters);
    getDataFromGoogle(key, scaleAndMapData);
  }
  else {
    showError("Sorry! You need to add a Google key to your URL. For example:\n\n" + location.href + "?key=MyGoogleDocKeyGoesHere")
  }
};



// Retrieves the spreadsheet with key (gdoc_key) and passes it to the callback (passed as: myCallback(data, tabletop) )
function getDataFromGoogle(gdoc_key, callback) {
  gdoc_url = "https://docs.google.com/spreadsheet/pub?hl=en_US&hl=en_US&key=" + gdoc_key + "&output=html"
  Tabletop.init( { key: gdoc_url,
                   callback: callback,
                   simpleSheet: true } )
}

// Main workhorse
function scaleAndMapData(data, tabletop) {
  scaledData = scaleData(data);
  mapData(scaledData);
}

function scaleData(data) {
  console.log("Hit processData!")
  values_only_array = extractValuesFromObjectArray(data)
  quantizer = new Quantizer(values_only_array, Config.scale)
  _.each(data, function(data_object) { data_object.scaled_value = quantizer.quantizeNumber(data_object.value) } )
  return data;
}

function mapData(data) {
  console.log("Hit mapData!");
  var map = L.map('map').setView([37.8, -96], 4);
  // Do shit inside here for now
  $.getJSON('data/us-states.json', function(states_json) {
    states_json = addDataToGeoJson(data, states_json)
    geojson = L.geoJson(states_json, {
      style: style
    }).addTo(map);
  });
}




// HELPFUL SHIT

// Config for map (from URI parameters)
var Config = {
  // Attributes with defaults
  color: 'green',
  scale: 5
};

// Set configuration for map by processing the URI parameters
function configureMapOptions(options) {
  pairs = _.pairs(options)
  _.each(pairs, function(pair) {
    k = pair[0]
    v = pair[1]
    console.log(v)
    // Hacky; may have more params that need to be coerced to int
    if(k === 'scale') {
      v = parseInt(v)
    }
    Config[k] = v
  })
  console.log(Config.lol)
}

// Given an array of objects, returns an array of the values contained in the 'value' slots of each object
function extractValuesFromObjectArray(data_object_array) {
  return _.map(data_object_array, function(data_object) { return data_object.value; } );
}
/*
//Test for extractValuesFromObjectArray()
obj_arr = [ { name: "dave", value: 2 }, { name: "berg", value: 5 } ]
console.log(obj_arr);
console.log(extractValuesFromObjectArray(obj_arr));
*/

// Quantizing data into buckets
// Given 
function Quantizer(data_array, scale) {
  min = d3.min(data_array)
  max = d3.max(data_array)
  //console.log("min: " + min)
  //console.log("max: " + max)

  this.quantizeNumber = d3.scale.quantize()
      .domain([min,max])
      .range(d3.range(1,scale + 1)) // Start with only mapping on 1-5 color scale
}
/*
//Test for Quantizer
data = [1,2,3,10];
var quantizer = new Quantizer(data)
console.log(quantizer.quantizeNumber(2));
console.log(quantizer.quantizeNumber(10));
*/

function showError(error_text) {
  // Can change below to some other flash-like thing
  alert(error_text)
}

// Adds `scaled_value` and `value` from data objects into geojson features as, eg, feature.properties.scaled_value
function addDataToGeoJson(data, geojson) {
  var data_hash = {};
  _.each(data, function(data_object) { data_hash[data_object['state']] = data_object } )
  _.each(geojson.features, function(feature) {
    geo_name = feature.properties.name;
    data_object = data_hash[geo_name];
    if(data_object) {
      feature.properties.scaled_value = data_object.scaled_value;
      feature.properties.value = data_object.value;
    }
    else {
      feature.properties.scaled_value = -1;
      feature.properties.value = -1;
    }
  });
  return geojson;
}

function style(feature) {
  console.log(Config.scale)
  color = getColor(feature.properties.scaled_value, Config.scale);
    return {
        fillColor: color,
        weight: 2,
        opacity: 1,
        color: 'white',
        //dashArray: '3',
        fillOpacity: 1
    };
}

// Make sure it deals with -1 (no data)
function getColor(num, scale) {
  if(Config.color === 'blue') {
    // Index in the array is 1 less than the scaled_number
    return colorbrewer.Blues[scale][num - 1];
  }
  // Default to green
  else {
    return colorbrewer.Greens[scale][num - 1];
  }
}

//////////////////////////////// End DG ////////////////////////////////



</script>






























